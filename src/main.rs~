use strum::IntoEnumIterator;
use strum_macros::EnumIter;

#[derive(Debug, Copy, Clone, EnumIter)]
enum Rank {
    ACE = 1,
    TWO = 2,
    THREE = 3,
    FOUR = 4,
    FIVE = 5,
    SIX = 6,
    SEVEN = 7,
    EIGHT = 8,
    NINE = 9,
    TEN = 10,
    JACK = 11,
    QUEEN = 12,
    KING = 13,

}

#[derive(Debug, Copy, Clone, EnumIter)]
enum Suit {
    CLUB,
    DIAMOND,
    HEART,
    SPADE
}

#[derive(Debug)]
struct Card {
    rank: Rank,
    suit: Suit,
}

struct Deck {
    cards: Vec<Card>,
}

impl Deck {
    fn new () -> Self {
	let mut cards = Vec::with_capacity(52);
	for rank in Rank::iter() {
	    for suit in Suit::iter() {
		cards.push(Card{rank, suit});
	    }
	}
	Deck {cards}
    }
}



enum PlayerAction {
    Fold,
    Check,
    Bet,
    Call,
    Raise,
}

struct Player {
    hand: Vec<Card>,    
    is_active: bool,
    money: u32,
}

impl Player {
    fn pay(&mut self, payment: u32) {
	self.money += payment
    }
}

#[derive(PartialEq)]
enum Street {
    Begin, 
    Preflop,
    Flop,
    Turn,
    River,
    End
}

/*
enum BettingState {
    Nothing,
    
}
 */

struct GameHand {
    players: &mut Vec<Player>,
    street: Street,
    //betting_state: BettingState,
    pot: u32, // current size of the pot
    flop: Option<Vec<Card>>,
    turn: Option<Card>,
    river: Option<Card>,
}

impl GameHand {
    fn new<'a> (players: &mut Vec<Player<'a>>) -> Self {
	GameHand {
	    players: players,
	    street: Street::Begin,
	    pot: 0,
	    flop: None,
	    turn: None,
	    river: None
	}

    }
    
    fn transition(&mut self) {
	match self.street {
	    Street::Begin => {
		self.collect_blinds();
		self.deal_hands();
		self.street = Street::Preflop;
	    },
	    Street::Preflop => {
	    	self.street = Street::Flop;
		self.deal_flop();		
	    },

	    Street::Flop => {
	    	self.street = Street::Turn;
		self.deal_turn();		
	    }
	    Street::Turn => {
	    	self.street = Street::River;
		self.deal_river();		
	    }
	    Street::River => {
	    	self.street = Street::End;
	    }
	    Street::End => () // we are already in the end street (from players folding during the street)
	}
    }

    fn collect_blinds(&mut self) {
	()
    }
    
    fn deal_hands(&mut self) {
	()
    }
    
    fn deal_flop(&mut self) {
	()
    }
    
    fn deal_turn(&mut self) {
	()
    }
    
    fn deal_river(&mut self) {
	()
    }
    
    fn play_street(&mut self) {
	let num_active = self.players.len(); // TODO where is_active is True!
	while num_active > 1 {
	    // iterate over the players and keep betting for folding
	    for player in self.players {
		if player.is_active {
		    match self.get_action(&player) {
			PlayerAction::Fold => {num_active -= 1; },
			PlayerAction::Check => (),
			PlayerAction::Call => (),
			PlayerAction::Raise => (),		    
		    }
		}
		if num_active == 1 {
		    break;
		}
	    }
	}
    }

    fn get_action(&self, player: &Player) -> PlayerAction {
	loop {
	    // get a valid action and check if it is valid
	    // will need UI here
	    break
	}
	PlayerAction::Fold
    }
    
    fn winning_index(&self) -> Option<usize> {
	Some(5) // TODO: keep track of who was the last persion standing
    }
}

struct Game {
    players: Vec<Player>,
    button: u8, // index of the player with the button
    small_blind: u32,
    big_blind: u32,
}


impl Game {
    fn new() -> Self {
	Game {
	    players: Vec::<Player>::with_capacity(9),
	    small_blind: 4,
	    big_blind: 8,
	    button: 0
	}
    }

    fn add_player(&mut self, player: Player) {
	self.players.push(player)
    }

    fn play_one_hand(&mut self) {
	let game_hand = GameHand {};
	while game_hand.street != Street::End {
	    game_hand.play_street();
	    game_hand.transition();	    	    
 	}
	let winning_player = self.players[game_hand.winning_index().unwrap()];
	winning_player.pay(game_hand.pot);
    }
    
}

fn main() {
    println!("Hello, world!");
    let deck = Deck::new();
    for card in deck.cards.iter() {
	println!("{:?}", card);
    }

    let game = Game::new();
}
